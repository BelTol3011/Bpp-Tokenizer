import os

Code = list[str]


# Path = tuple[str, list[str]]

class Path(tuple[str, list[str]]):
    def __hash__(self):
        return hash(get_mcfunction_str(self))


def get_mcfunction_str(path: Path):
    path_str = "/".join(path[1])
    return f"{path[0]}:{path_str}"


def split_list_file(input_code: Code) -> dict[str: Code]:
    """Splits a .list.mcfunction file into seperate functions and returns their location"""

    section_indices = [i for i, line in enumerate(input_code) if line.startswith("###")] + [None]

    sections = {}
    for i in range(len(section_indices) - 1):
        current = section_indices[i]
        next_ = section_indices[i + 1]
        section = input_code[current + 1:next_]

        name = input_code[current].rstrip().split()[-1]

        sections.update({name: section})

    return sections


def karma_util(string: str, search_char: str = "$") -> list[int]:
    """
    Searches a string for the search_char with attention to parentheses and stuff.
    :param string: the string to be scanned
    :param search_char: the char that is searched for in `string`
    :return: the list of indeces in `string` that match `search_char` with attention to parentheses and stuff
    """
    assert len(search_char) == 1
    indeces = []

    in_string = False
    in_comment = False
    karma = 0
    for i, char in enumerate(string):
        if char in "({[":
            karma += 1
        elif char in ")}]":
            karma -= 1
        elif char == '"':
            in_string = not in_string
        elif char == "#" and not in_string:
            in_comment = True
        elif char == "\n":
            in_string = False
            in_comment = False
            karma = 0

        if karma == 0 and not in_string and char == search_char and not in_comment:
            indeces.append(i)

    return indeces


def link(code: Code, function_dict: dict[str: tuple[Path, Code]]) -> Code:
    """replaces the function tag $function with the real function path namespace:.../function
    Example ( namespace="namespace", function_dict={"mcutils": ["mcutils", "create_object"]} ):
        $foo -> namespace:path/.../foo
        $create_obj@mcutils -> namespace:mcutils/create_obj
    """
    for i, _ in enumerate(code):

        line = code[i]

        if line.startswith("#"):
            continue

        try:
            index = line.index("function $")
            replacement = get_mcfunction_str(function_dict[line[index+10:]][0])
            code[i] = line[:index + 9] + replacement
        except ValueError:
            if line.startswith("$"):
                name = line[1:]
                # no need to link the functions since it is iterating over them nonetheless
                line_ = function_dict[name][1]
                code[i:i] = [f"##! [{name}] begin", *line_, f"##! [{name}] end"]



    return code


def preprocess(code: Code, attributes: set[str]):
    for i, line in enumerate(code):
        try:
            index = line.index("?")
        except ValueError:
            continue
        if index != 1:
            continue

        attribute = line[2:].rstrip()
        if attribute not in attributes:
            code[i + 1] = "# " + code[i + 1]

    return code


def batch_link(function_lists: list[tuple[Path, Code]], attributes: set[str]) -> dict[Path: Code]:
    functions_namescodes: dict[str: tuple[Path, Code]] = {}
    for path, function_list in function_lists:
        _functions = split_list_file(function_list)

        for name in _functions:
            # extend the path to contain the function name
            _path = Path((path[0], path[1] + [name]))
            code = preprocess(_functions[name], attributes)
            functions_namescodes.update({name: (_path, code)})

    linked_functions: dict[Path: Code] = {}
    for name in functions_namescodes:
        path, code = functions_namescodes[name]

        linked_code = link(code, functions_namescodes)

        linked_functions.update({path: linked_code})

    return linked_functions


def pp_functions(functions: dict[Path: Code]):
    print("Listing:")
    for path in functions:
        print(f"==> {get_mcfunction_str(path)}")
        print("\n".join(functions[path]))


def to_datapack(function_lists: list[tuple[Path, Code]], output_path: str, attributes: set[str]):
    files = batch_link(function_lists, attributes)
    pp_functions(files)
    os.makedirs(f"{output_path}/data/minecraft/tags/functions", exist_ok=True)

    with open(f"{output_path}/pack.mcmeta", "w") as f:
        f.write('{"pack": {"pack_format": -2, "description": "Datapack generated by minecraft_utils_v2.py"}}')

    with open(f"{output_path}/data/minecraft/tags/functions/load.json", "w") as f:
        f.write('{"values":[]}')
    with open(f"{output_path}/data/minecraft/tags/functions/tick.json", "w") as f:
        f.write('{"values":[]}')

    for file in files:
        path = f"Datapack/data/{file[0]}/functions/{'/'.join(file[1][:-1])}"
        os.makedirs(path, exist_ok=True)

        with open(path + f"/{file[1][-1]}.mcfunction", "w") as f:
            f.write("\n".join(files[file]))


def main():
    """How to compile:
    1. split, link and copy libmcutils into the 'mcutils' path
    2. generate the unlinked user code (.list.mcfunction) via the python script
    3. link and copy the user code with the mcutils function locations
    """
    with open("libs/mcutils.list.mcfunction", "r") as f:
        code = f.read().split("\n")
    to_datapack([(Path(("mcutils", [])), code)], "../Datapack", {"debug"})


if __name__ == "__main__":
    main()
